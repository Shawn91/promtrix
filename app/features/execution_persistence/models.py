import uuid
from datetime import datetime
from typing import Optional, List

from sqlmodel import Field, SQLModel, Relationship


class PromptTemplate(SQLModel, table=True):
    """
    PromptTemplate represents a prompt template that may contain placeholders for variables.
    A plaint text prompt without any placeholders is also supported.
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    template: str  # Store as string, convert to jinja2 Template when needed
    description: Optional[str] = None

    prompts: List["Prompt"] = Relationship(back_populates="template")
    executions: List["Execution"] = Relationship(back_populates="prompt_template")


class Prompt(SQLModel, table=True):
    """
    Represents a real prompt that can be used to generate a response.
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    user: str = Field(description="user prompt")
    system: Optional[str] = Field(default=None, description="system prompt")
    template_id: uuid.UUID = Field(foreign_key="prompttemplate.id")
    created_at: datetime = Field(description="The date and time when the prompt was created")
    token_count: Optional[int] = Field(default=None, description="The number of tokens in the prompt")

    template: PromptTemplate = Relationship(back_populates="prompts")
    executions: List["Execution"] = Relationship(back_populates="prompt")


class LLMService(SQLModel, table=True):
    """
    LLMService represents a llm model or a LLM-backed service
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    model: str
    model_provider: Optional[str] = Field(default=None, description="The provider of the llm model. E.g. OpenAI, etc")
    service_provider: Optional[str] = Field(
        default=None,
        description="The provider of the llm service. E.g. OpenRouter, etc",
    )
    model_version: Optional[str] = Field(default=None, description="The version of the llm model")
    api_base: str
    description: Optional[str] = None
    keys: Optional[List[str]] = Field(default=None, description="The keys required to access the service")

    executions: List["Execution"] = Relationship(back_populates="llm_service")


class Task(SQLModel, table=True):
    """
    Represents a specific problem that needs to be solved.
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    name: str
    description: str

    executions: List["Execution"] = Relationship(back_populates="task")


class LLMResponse(SQLModel, table=True):
    """
    Represents a response generated by a llm_service
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    content: str
    role: str = Field(description="user or assistant role. future role may include agent, etc")
    finish_reason: str = Field(description="The reason why the execution finished")
    index: int = Field(description="The index of the response in the list of responses generated by the llm_service")


class Execution(SQLModel, table=True):
    """
    Represents a prompt being sent to a llm_service
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    request_id: str | None = Field(default=None, description="The id of the id provided by the llm service")
    prompt_id: uuid.UUID = Field(foreign_key="prompt.id")
    llm_service_id: uuid.UUID = Field(foreign_key="llmservice.id")
    task_id: uuid.UUID = Field(foreign_key="task.id")
    execution_group_id: Optional[uuid.UUID] = Field(default=None, foreign_key="executiongroup.id")
    duration: int = Field(description="The duration of the execution in milliseconds")
    cost: Optional[float] = Field(default=None, description="The cost of the execution")
    response_ids: List[str] = Field(description="The response generated by the llm_service")
    token_count: int = Field(description="The number of tokens in the response")
    created_at: datetime = Field(description="The date and time when the execution was created")

    # llm parameters
    api_key: str = Field(description="The API key used to access the llm service")
    temperature: Optional[float] = Field(default=None, description="The temperature used for sampling")
    max_completion_tokens: Optional[int] = Field(default=None, description="The maximum number of tokens to generate")
    top_k: Optional[int] = Field(default=None, description="The number of top-k tokens to keep")
    top_p: Optional[float] = Field(default=None, description="The cumulative probability threshold")
    stop: Optional[str] = Field(default=None, description="The stop tokens for the generation")
    n: Optional[int] = Field(default=None, description="The number of responses to generate")
    logprobs: Optional[int] = Field(default=None, description="The number of logprobs to return")
    presence_penalty: Optional[float] = Field(default=None, description="The presence penalty")
    frequency_penalty: Optional[float] = Field(default=None, description="The frequency penalty")
    user: Optional[str] = Field(default=None, description="user id that represents the end user")
    response_format: Optional[dict] = Field(default=None, description="The type of response expected")
    seed: Optional[int] = Field(default=None, description="The seed for the generation")

    prompt: Prompt = Relationship(back_populates="executions")
    llm_service: LLMService = Relationship(back_populates="executions")
    task: Task = Relationship(back_populates="executions")
    execution_group: Optional["ExecutionGroup"] = Relationship(back_populates="executions")
    evaluations: List["Evaluation"] = Relationship(back_populates="execution")
    responses: List[LLMResponse] = Relationship(back_populates="execution")


class ExecutionGroup(SQLModel, table=True):
    """
    Represents a group of Executions that were executed together.
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    created_at: datetime = Field(description="The date and time when the group was created")
    duration: int = Field(description="The total duration of the group in milliseconds")
    cost: Optional[float] = Field(default=None)

    executions: List[Execution] = Relationship(back_populates="execution_group")


class Evaluation(SQLModel, table=True):
    """
    Represents an evaluation of an execution using a specific method or metric
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    execution_id: uuid.UUID = Field(foreign_key="execution.id")
    evaluation_group_id: Optional[uuid.UUID] = Field(default=None, foreign_key="evaluationgroup.id")
    method: str = Field(description="The method or metric used for evaluating the execution")
    score: float = Field(description="The score obtained by the evaluation")
    created_at: datetime = Field(description="The date and time when the evaluation was created")
    duration: int = Field(description="The duration of the evaluation in milliseconds")
    cost: Optional[float] = Field(default=None, description="The cost of the evaluation")

    execution: Execution = Relationship(back_populates="evaluations")
    evaluation_group: Optional["EvaluationGroup"] = Relationship(back_populates="evaluations")


class EvaluationGroup(SQLModel, table=True):
    """
    Represents a group of Evaluation objects that were performed together.
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    created_at: datetime = Field(description="The date and time when the group was created")
    duration: int = Field(description="The total duration of the group in milliseconds")
    cost: Optional[float] = Field(default=None)

    evaluations: List[Evaluation] = Relationship(back_populates="evaluation_group")


class Dataset(SQLModel, table=True):
    """
    Represents a dataset used for testing or evaluating a model or a prompt
    """

    id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    name: str
    description: str
    url: str
    size: int = Field(description="The size of the dataset in bytes")
    count: int = Field(description="The number of examples in the dataset")
    created_at: datetime = Field(description="The date and time when the dataset was created")

    executions: List[Execution] = Relationship(back_populates="dataset")
